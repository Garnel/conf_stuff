" This is a template vimrc by Garnel
" 2012-12-30

"""""""""""""""""""" Global vars, funcs """""""""""""""
" Is windows or not
if (has("win32") || has("win95") || has("win64") || has("win16"))
    let g:iswindows = 1
else
    let g:iswindows = 0
endif

" If has tab
if v:version < 700
    let g:hastab = 0
else
    let g:hastab = 1
endif

"Open in a new buffer or vsplit(version < 7.0, no tab)
function! OpenNew(filename)
    "get fullfile name by replacing beginning "~/" to "$HOME/"
    "If you are in windows, set a environment varible HOME to where you put _vimrc
    "Generally speaking, '~' stands fo home directory, so I recommend you set it
    "to your home directory too, such as "C:\Users\Garnel"
    let l:fullfn = substitute(a:filename, "^\\~/", $HOME . "/", "")
    
    if g:hastab == 0 "version lower than 7.0
        exec "vsplite " . l:fullfn
        return 
    endif

    "find in current tab
    let bufwinnr = bufwinnr(l:fullfn) "get the window number of a specific buffer
    if bufwinnr != -1
        exec bufwinnr . "wincmd w"
        return
    else
        " find in each tab
        tabfirst
        let tab = 1
        while tab <= tabpagenr("$") "get the number of a tab page
            let bufwinnr = bufwinnr(l:fullfn)
            if bufwinnr != -1
                exec "normal " . tab . "gt"
                exec bufwinnr . "wincmd w"
                return
            endif
            tabnext
            let tab = tab + 1
        endwhile
        " not exist, new tab
        exec "tabnew " . l:fullfn
    endif
endfunction

"""""""""""""""""""" General """"""""""""""""""""""""""
"no compatible with vi
set nocompatible

"Sets how many lines of history VIM has to remember
set history=1000

"Enable filetype plugin
filetype plugin on
filetype indent on

"set to auto read when a file is changed from the outside
set autoread

"set linenumber (= set number)
set nu

"switch syntax highlighting on
syntax on
syntax enable
set background=dark
colorscheme solarized  "nice theme! google solarized and you will find it

" set guifont
if g:iswindows == 1
    set guifont=Consolas:h13:cANSI
endif

"make backspace work like most other apps
set backspace=2

"encoding
set encoding=utf8
set fencs=utf8,gb18030,gbk,gb2312,utf-16,big5

"turn backup off, since most stuff is in SVN, git anyway...
set nobackup
set nowb
set noswapfile

"Text, tab and indent related
set expandtab
set shiftwidth=4
set tabstop=4
set smarttab        
set softtabstop=4   "makes spaces feel like tabs (like deleting)

set wrap
set linebreak
set textwidth=100

set autoindent
set smartindent

"set 5 lines to the cursors - when moving vertical
set so=5

"turn on wild menu
set wildmenu        "command-line completion

"always show current position
set ruler

"set the height of commandbar
set cmdheight=2

"change buffer = without saving
set hidden

"ignore case when searching
set ignorecase
set smartcase

"hightlight search things
set hlsearch

"make search act like search in modern browsers
set incsearch
"don't redraw while executing macros
set nolazyredraw

"for regular expressions
set magic

"show matching bracets when text indicator is over them
set showmatch

"how many tenths of a second to blink
set mat=2

"No sounds on errors
set noerrorbells
set novisualbell
set t_vb=
set tm=500

" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
  set mouse=a
endif

" code folder
set foldmethod=marker

"With a map leader it's possible to do extra key combinatons
"like <leader>w saves the current file
let mapleader = ","
let g:mapleader = ","

"Fast saving
nmap <leader>w :w!<cr>

"""""""""""""""""""" editing vimrc """"""""""""""""""""
" Get name of vimrc
let g:vimrc = ".vimrc"
let g:gvimrc = ".gvimrc"
if (g:iswindows == 1)
    let g:vimrc = "_vimrc"
    let g:gvimrc = "_gvimrc"
endif

let g:vimrc_withdir = $HOME . "/" . g:vimrc

" Load vimrc
if !exists("*LoadVimrc")
    function LoadVimrc()
        exec "source " . $HOME . "/" . g:vimrc
        if has("gui_running")
            exec "source " . $HOME . "/" . g:gvimrc
        endif
    endfunction
endif

"Fast reload .vimrc
map <silent> <leader>ss :call LoadVimrc()<cr>

"Fast edit .vimrc
map <silent> <leader>ee :call OpenNew(g:vimrc_withdir)<cr>

"When .vimrc is edited, reload it
autocmd! bufwritepost g:vimrc, g:gvimrc call LoadVimrc()

"""""""""""""""""""" For coding """""""""""""""""""""""
" Append modeline after last line in buffer.
" Use substitute() instead of printf() to handle '%%s' modeline in LaTeX
" files.
function! AppendModeline()
  let l:modeline = printf(" vim: set ts=%d sw=%d tw=%d sts=%d:",
        \ &tabstop, &shiftwidth, &textwidth, &sts)
  let l:modeline = substitute(&commentstring, "%s", l:modeline, "")
  call append(line("$"), "")  "empty line
  call append(line("$"), l:modeline)
endfunction
nnoremap <silent> <Leader>ml :call AppendModeline()<CR>

" Supported by DoxygenToolkit, a nice plugin to make doc comment
let g:DoxygenToolkit_authorName="Garnel"

"""""""""""""""""""" Using cscope """""""""""""""""""""
"map <F12> :call Do_CsTag()<CR>
"nmap <C-@>s :cs find s <C-R>=expand("<cword>")<CR><CR>:copen<CR>
"nmap <C-@>g :cs find g <C-R>=expand("<cword>")<CR><CR>
"nmap <C-@>c :cs find c <C-R>=expand("<cword>")<CR><CR>:copen<CR>
"nmap <C-@>t :cs find t <C-R>=expand("<cword>")<CR><CR>:copen<CR>
"nmap <C-@>e :cs find e <C-R>=expand("<cword>")<CR><CR>:copen<CR>
"nmap <C-@>f :cs find f <C-R>=expand("<cfile>")<CR><CR>:copen<CR>
"nmap <C-@>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>:copen<CR>
"nmap <C-@>d :cs find d <C-R>=expand("<cword>")<CR><CR>:copen<CR>
"function Do_CsTag()
"    let dir = getcwd()
"    if filereadable("tags")
"        if(g:iswindows==1)
"            let tagsdeleted=delete(dir."\\"."tags")
"        else
"            let tagsdeleted=delete("./"."tags")
"        endif
"        if(tagsdeleted!=0)
"            echohl WarningMsg | echo "Fail to do tags! I cannot delete the tags" | echohl None
"            return
"        endif
"    endif
"    if has("cscope")
"        silent! execute "cs kill -1"
"    endif
"    if filereadable("cscope.files")
"        if(g:iswindows==1)
"            let csfilesdeleted=delete(dir."\\"."cscope.files")
"        else
"            let csfilesdeleted=delete("./"."cscope.files")
"        endif
"        if(csfilesdeleted!=0)
"            echohl WarningMsg | echo "Fail to do cscope! I cannot delete the cscope.files" | echohl None
"            return
"        endif
"    endif
"    if filereadable("cscope.out")
"        if(g:iswindows==1)
"            let csoutdeleted=delete(dir."\\"."cscope.out")
"        else
"            let csoutdeleted=delete("./"."cscope.out")
"        endif
"        if(csoutdeleted!=0)
"            echohl WarningMsg | echo "Fail to do cscope! I cannot delete the cscope.out" | echohl None
"            return
"        endif
"    endif
"    if(executable('ctags'))
"        "silent! execute "!ctags -R --c-types=+p --fields=+S *"
"        silent! execute "!ctags -R --c++-kinds=+p --fields=+iaS --extra=+q ."
"    endif
"    if(executable('cscope') && has("cscope") )
"        if(g:iswindows!=1)
"            silent! execute "!find . -name '*.h' -o -name '*.c' -o -name '*.cpp' -o -name
"                        \'*.java' -o -name '*.cs' > cscope.files"
"        else
"            silent! execute "!dir /s/b *.c,*.cpp,*.h,*.java,*.cs >> cscope.files"
"        endif
"        silent! execute "!cscope -b"
"        execute "normal :"
"        if filereadable("cscope.out") 
"            execute "cs add cscope.out"
"        endif
"    endif
"endfunction

" Bash like keys for the command line
cnoremap <C-A>      <Home>
cnoremap <C-E>      <End>
cnoremap <C-K>      <C-U>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Moving around, tabs and buffers
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" Map space to / (search) and c-space to ? (backgwards search)
map <space> /
map <c-space> ?
map <silent> <leader><cr> :noh<cr>

" Smart way to move btw. windows
map <C-j> <C-W>j
map <C-k> <C-W>k
map <C-h> <C-W>h
map <C-l> <C-W>l

" Tab configuration
map <leader>tn :tabnew<cr>
map <leader>te :tabedit
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove
map <leader>tj :tabnext<cr>
map <leader>tk :tabprevious<cr>

""""""""""""""""""""""""""""""
" => Statusline
""""""""""""""""""""""""""""""
" Always hide the statusline
set laststatus=2

" Format the statusline
set statusline=\ %{HasPaste()}%F%m%r%h\ %w\ \ CWD:\ %r%{CurDir()}%h\ \ \ Line:\ %l/%L:%c


function! CurDir()
    let curdir = substitute(getcwd(), '/Users/amir/', "~/", "g")
    return curdir
endfunction

function! HasPaste()
    if &paste
        return 'PASTE MODE  '
    else
        return ''
    endif
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" => Parenthesis/bracket expanding
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
vnoremap $1 <esc>`>a)<esc>`<i(<esc>
vnoremap $2 <esc>`>a]<esc>`<i[<esc>
vnoremap $3 <esc>`>a}<esc>`<i{<esc>
vnoremap $$ <esc>`>a"<esc>`<i"<esc>
vnoremap $q <esc>`>a'<esc>`<i'<esc>
vnoremap $e <esc>`>a"<esc>`<i"<esc>

" Map auto complete of (, ", ', [
inoremap $1 ()<esc>i
inoremap $2 []<esc>i
inoremap $3 {}<esc>i
inoremap $4 {<esc>o}<esc>O
inoremap $q ''<esc>i
inoremap $e ""<esc>i
inoremap $t <><esc>i
